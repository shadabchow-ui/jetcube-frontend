import type { PagesFunction } from '@cloudflare/workers-types';

export interface Env {
  JETCUBE_R2?: R2Bucket;
  JETCUBE_PRODUCTS?: R2Bucket;
}

function jsonRes(body: any, status = 200, extra: Record<string, string> = {}) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "content-type": "application/json; charset=utf-8",
      "cache-control": "public, max-age=300",
      "x-pdp-handler": "functions/api/pdp/[slug].ts",
      ...extra,
    },
  });
}

function looksLikeAsin(s: string): boolean {
  const t = (s || "").trim();
  return /^[A-Za-z0-9]{10}$/.test(t);
}

async function getJsonFromR2(bucket: R2Bucket, key: string): Promise<any | null> {
  const obj = await bucket.get(key);
  if (!obj) return null;

  const isGzip = key.endsWith(".gz") || obj.httpMetadata?.contentEncoding === "gzip";

  if (isGzip && typeof DecompressionStream !== "undefined") {
    const ds = new DecompressionStream("gzip");
    const decompressedStream = obj.body.pipeThrough(ds);
    const text = await new Response(decompressedStream).text();
    return JSON.parse(text);
  }

  return JSON.parse(await obj.text());
}

/**
 * Global ASIN->handle map cache (module scope).
 * Cloudflare will reuse the same isolate for many requests, so this avoids
 * re-downloading the map every time.
 */
let _asinMapCache: Record<string, string> | null = null;
let _asinMapCacheKey: string | null = null;
let _asinMapTriedOnce = false;

async function loadAsinMap(bucket: R2Bucket): Promise<{ map: Record<string, string>; key: string } | null> {
  // If we already loaded it successfully, reuse it.
  if (_asinMapCache && _asinMapCacheKey) {
    return { map: _asinMapCache, key: _asinMapCacheKey };
  }

  // If we already tried and failed in this isolate, don't hammer R2.
  if (_asinMapTriedOnce) return null;
  _asinMapTriedOnce = true;

  // Try a few deterministic locations so you can choose where to upload it.
  const candidates = [
    "indexes/_asin_map.json.gz",
    "indexes/_asin_map.json",
    "_asin_map.json.gz",
    "_asin_map.json",

    // optional future naming (if you decide to standardize)
    "indexes/asin_to_handle.json.gz",
    "indexes/asin_to_handle.json",
  ];

  for (const key of candidates) {
    try {
      const j = await getJsonFromR2(bucket, key);
      if (j && typeof j === "object") {
        // Expect: { "B0XXXX....": "some-handle" }
        _asinMapCache = j as Record<string, string>;
        _asinMapCacheKey = key;
        return { map: _asinMapCache, key };
      }
    } catch {
      // ignore parse errors and keep trying
    }
  }

  return null;
}

async function resolveAsinToHandle(bucket: R2Bucket, asin: string): Promise<{ handle: string; key: string; mode: "map" | "alias" } | null> {
  const a = asin.trim().toUpperCase();

  // 1) Preferred: global map lookup (generated by your converter)
  const loaded = await loadAsinMap(bucket);
  if (loaded?.map) {
    const handle = String((loaded.map as any)[a] || "").trim();
    if (handle) return { handle, key: loaded.key, mode: "map" };
  }

  // 2) Fallback: per-ASIN alias objects (works, but not ideal at scale)
  const tried = [
    `asins/${a}.json`,
    `asin/${a}.json`,
    `asins/${a}.json.gz`,
    `asin/${a}.json.gz`,
  ];

  for (const key of tried) {
    try {
      const j = await getJsonFromR2(bucket, key);
      const handle = String(j?.handle || "").trim();
      if (handle) return { handle, key, mode: "alias" };
    } catch {
      // ignore parse errors here; continue trying other keys
    }
  }

  return null;
}

export const onRequest: PagesFunction<Env> = async ({ params, env }) => {
  let slug = decodeURIComponent(String(params?.slug || "")).trim();

  if (!slug) {
    return jsonRes({ ok: false, error: "missing_slug" }, 400);
  }

  // Check which R2 binding is available
  const bucket = env.JETCUBE_R2 || env.JETCUBE_PRODUCTS;
  if (!bucket) {
    return jsonRes({ ok: false, error: "missing_r2_binding" }, 500);
  }

  // âœ… If the slug looks like an ASIN, resolve it to a handle using the global ASIN map (preferred).
  // This makes /p/{ASIN} work even though products are stored by handle.
  let asinResolved: { handle: string; key: string; mode: "map" | "alias" } | null = null;
  const originalSlug = slug;

  if (looksLikeAsin(slug)) {
    asinResolved = await resolveAsinToHandle(bucket, slug);
    if (asinResolved?.handle) {
      slug = asinResolved.handle;
    }
  }

  // Priority order of R2 keys to check (handle-based)
  const triedKeys = [
    `product/${slug}.json.gz`,
    `product/${slug}.json`,
    `products/${slug}.json.gz`,
    `products/${slug}.json`,
    `${slug}.json.gz`,
    `${slug}.json`,
  ];

  for (const key of triedKeys) {
    const obj = await bucket.get(key);
    if (!obj) continue;

    try {
      const isGzip = key.endsWith(".gz") || obj.httpMetadata?.contentEncoding === "gzip";
      let data;

      if (isGzip && typeof DecompressionStream !== "undefined") {
        const ds = new DecompressionStream("gzip");
        const decompressedStream = obj.body.pipeThrough(ds);
        const text = await new Response(decompressedStream).text();
        data = JSON.parse(text);
      } else {
        data = JSON.parse(await obj.text());
      }

      return jsonRes(
        {
          ok: true,
          slug,
          data,
          product: data,
          asinResolved: asinResolved
            ? { from: originalSlug, key: asinResolved.key, handle: asinResolved.handle, mode: asinResolved.mode }
            : null,
        },
        200,
        {
          "x-pdp-key": key,
          "x-pdp-is-gzip": String(isGzip),
          ...(asinResolved
            ? {
                "x-pdp-asin-resolved": "1",
                "x-pdp-asin-resolve-mode": asinResolved.mode,
                "x-pdp-asin-resolve-key": asinResolved.key,
              }
            : {}),
          ...(_asinMapCacheKey ? { "x-pdp-asin-map-key": _asinMapCacheKey } : {}),
        }
      );
    } catch (err: any) {
      return jsonRes(
        { ok: false, error: "parse_failed", key, message: err?.message || String(err) },
        500
      );
    }
  }

  return jsonRes(
    { ok: false, error: "not_found", slug, triedKeys, asinResolved },
    404
  );
};
